{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to My-Cyber-Knowledge","text":"<p>This is my cyber security acknowlege wiki.</p>"},{"location":"#section-breakdown","title":"Section Breakdown","text":"<ul> <li>Github</li> <li>Forensic</li> </ul>"},{"location":"forensic/","title":"Forensic","text":"<p>Forensics is the application of scientific methods and techniques to investigate crimes and gather evidence that can stand up in a court of law. It spans multiple disciplines, including digital forensics, forensic biology, forensic chemistry, and forensic anthropology. By methodically analyzing data and artifacts, forensic experts play a crucial role in solving crimes and ensuring justice.</p>"},{"location":"forensic/#tools","title":"Tools","text":"<ul> <li><code>dd.exe</code> - dd.exe is a Windows port of the classic Unix disk cloning and imaging tool.</li> <li><code>winpmem.exe</code> - WinPmem is a powerful memory acquisition tool designed for Windows systems.</li> <li><code>TestDisk</code> - TestDisk checks the partition and boot sectors of your disks. It is very useful in recovering lost partitions.</li> <li><code>PhotoRec</code> - PhotoRec is file data recovery software designed to recover lost pictures from digital camera memory or even hard disks.</li> <li><code>Volatility</code> - The Volatility Framework is a completely open collection of tools, implemented in Python under the GNU General Public License, for the extraction of digital artifacts from volatile memory (RAM) samples.</li> </ul>"},{"location":"forensic/#dd","title":"dd","text":""},{"location":"forensic/#winpmem","title":"WinPmem","text":""},{"location":"forensic/#testdisk","title":"TestDisk","text":""},{"location":"forensic/#photorec","title":"PhotoRec","text":""},{"location":"forensic/#volatility","title":"Volatility","text":""},{"location":"github/","title":"Github","text":""},{"location":"github/#generate-new-ssh-key","title":"Generate new ssh key","text":"<pre><code>ssh-keygen -t ed25519 -C \"your_email@example.com\"\n</code></pre>"},{"location":"github/#workflows","title":"Workflows","text":"<p>GitHub workflows are automated processes defined in YAML files that enable developers to streamline tasks such as code building, testing, deployment, and custom automation based on events like code pushes or pull requests.</p>"},{"location":"github/#structure","title":"Structure","text":"<p>Your workflows must be located in <code>.github/workflows</code> directory.</p> <pre><code>.\n\u251c\u2500\u2500 .git/\n    \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 .github/\n    \u2514\u2500\u2500 workflows/\n        \u2514\u2500\u2500 &lt;your_workflow&gt;.yml\n...\n</code></pre>"},{"location":"github/#yaml-file-structure","title":"Yaml file structure","text":"<p>To set up a valid GitHub workflow, you must include some required parameters in your YAML file. Below are key parameters and their descriptions:</p> <p><code>name</code> : The name of the workflow. This is a descriptive identifier for the workflow that appears in the GitHub Actions UI.</p> <p><code>on</code> : Specifies the events that trigger the workflow. Common events are <code>push</code>, <code>pull_request</code>, and custom events.</p> <p><code>on.push.branches</code> : Specifies which branches trigger the workflow on push events.</p> <p><code>env</code> : Defines environment variables that are available to all jobs and steps in the workflow.</p> <p><code>jobs</code> : A collection of jobs to be executed in the workflow. Each job can run on a specific environment and container.</p> <p><code>jobs.&lt;your_job&gt;.runs-on</code> : Specifies the type of machine to run the job on. Common options are <code>ubuntu-latest</code>, <code>windows-latest</code>, and <code>macos-latest</code>.</p> <p><code>jobs.&lt;your_job&gt;.container</code> : Defines the container environment for the job. This is useful for running jobs in a custom Docker image.</p> <p><code>jobs.&lt;your_job&gt;.steps</code> : Defines the individual steps to be executed in the job. Each step can run commands, use actions, or set up environments.</p> <p>To fail a job's step manually, you can <code>exit 1</code> when running a command.</p> <p>Here is a structure of a github workflow yaml file :</p> <pre><code>name: &lt;workflow_name&gt;\n\non:\n  push:\n    branches:\n      - &lt;branch1&gt;\n      - &lt;branch2&gt;\n  pull_request:\n    branches:\n      - &lt;branch1&gt;\n      - &lt;branch2&gt;\n\nenv:\n  ENV_KEY: &lt;value&gt;\n\njobs:\n  &lt;your_job_name&gt;:\n    runs-on: &lt;chosen_os&gt;\n    container:\n      image: &lt;chosen_image&gt;\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n      - name: &lt;your_step_name_1&gt;\n        run: &lt;your_command&gt;\n      - name: &lt;your_step_name_2&gt;\n        timeout-minutes: 2\n        run: &lt;your_command&gt;\n\n  &lt;your_job_2&gt;:\n  ...\n</code></pre> <p>Here is an exemple of a basic github workflow :</p> <pre><code>name: Makefile CI\n\non:\n  push:\n    branches: [ \"main\" ]\n  pull_request:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: configure\n      run: ./configure\n\n</code></pre> <p>More documentation on github.</p>"}]}